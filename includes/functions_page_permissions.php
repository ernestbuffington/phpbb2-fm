<?php
/*
  phpBBDoctor Cache Functions
  Copyright www.phpBBDoctor.com
  GPL License
  
  Purpose
  These functions are used to write out a cache file
  or read from a database table to populate a cache.
  The cache folder is passed as part of the filename
  Also included is an array of rows and a row structure
  The output file looks like a series of array assignment
  statements, used to replace a database query with a
  lookup for infrequenly changing values. Sample uses might
  include the following tables: phpbb_ranks, phpbb_config,
  phpbb_smilies, phpbb_words, and other small and 
  infrequently changing tables.
  
  Parameters
  	$output_file	Fully qualified path to cache output
  	$table_name	Table to be cached
  	$array_name	Name of array cache. For example, the
  			cache for phpbb_config is 'board_config'
  	$row_structure	array of table columns, passed by ref
  			to save some memory for larger tables
  	$cache_key	key column from the table, will be
  			used as the array index key value in
  			the cache. If missing, this part will
  			be left off. $cache_key is only passed
  			for multi-dimension arrays. Note that
  			there is a special value ##SEQ## that
  			will imply that a sequential number will
  			be used as the key.
  
  Output Formats	Output formats vary based on the type
			of array specified by $cache_key. If
			$cache_key is blank then an array of
			the format $array['key'] = 'value' is
			created, like $board_config. If a
			$cache_key of ##SEQ## is passed then 
			an array of $array[0]['key'] = 'value'
			is created. See $ranksrow as an example.
			Finally, if $cache_key is non-blank, then
			an array of $array['key_name']['key'] = 'value'
			is created. For an example, see the
			flags array.

  Return Values 	None
*/

function write_cache_file ($output_file, $table_name, $array_name, &$row_structure, $cache_key = '')
{
	global $db, $phpbb_root_path, $phpEx, $board_config, $lang;

	$cache_sql = '';
	
	if ( ($cache_key <> '') && ($cache_key <> '##SEQ##') )
	{
		$cache_sql = ",	$cache_key as cache_key ";
	}

	$sql = 'SELECT	* ' . $cache_sql . '
		FROM ' . $table_name;
	if (! ($result = $db->sql_query($sql)) )
	{
		message_die (GENERAL_ERROR, 'Invalid cursor', '', __LINE__, __FILE__, $sql);
	}

	$data_set = array();
	$data_set = $db->sql_fetchrowset($result);
	$db->sql_freeresult($result);

	// Start page structure with standard header info
    $contents = "<?php\n";
    $contents .= "//\tAutogenerated Cache File\n";
    $contents .= "//\tLast Cache Update " . date('Y-m-d h:i:s', time()) . "\n\n";
	$contents .= "//\tTable Cache for $table_name\n";
	$contents .= "//\tArray Name $array_name\n";
	if ($cache_key <> '')
	{
		$contents .= "//\tArray Key $cache_key\n";
	}

	$contents .= "//\tRecord Structure\n";


	// Dump the structure of the record we're caching
	// purely for reference
	foreach($row_structure as $key => $value)
	{
		$contents .= "//\t\t$key\n";
	}
	$contents .= "//\n\n";

	// Standard phpBB Hack Prevent technique
    $contents .= "if (!defined('IN_PHPBB'))\n{\n\tdie('Hacking attempt');\n}\n\n";

	// Finished the header, now let's dump out the table
	// contents in the required format. The function will
	// handle either single or multi-dimension array output
	// formats. There are three types of formats handled
	// by this routine. 
	// Single dimension arrays are $array_name['key'] = ['value'];
	// Multi dimension arrays are $array_name['cache_key_value']['key'] = ['value'];
	// Multi dimension sequenced arrays are $array_name[sequence_number]['key'] = ['value'];

	$row_count = count($data_set);
	for($i = 0; $i < $row_count; $i++)
	{
		switch($cache_key)
		{
			case '':
				foreach($row_structure as $key => $value)
				{
					$contents .= $array_name . "['" . addslashes($data_set[$i][$key]) . "'] = '" . $data_set[$i][$value] . "';\n";
				}
				break;
			case '##SEQ##':
				foreach($row_structure as $key => $value)
				{
					$contents .= $array_name . "['" . $i . "']['" . $key . "'] = '" . addslashes($data_set[$i][$value]) . "';\n";
				}
				break;
			default:
				foreach($row_structure as $key => $value)
				{
					$contents .= $array_name . "['" . addslashes($data_set[$i]['cache_key']) . "']" . "['$key'] = '" . addslashes($data_set[$i][$value]) . "';\n";
				}
				break;
		}
	}
	$contents .= "\n//\n//\tEnd of Table Cache for $table_name\n//\n\n?>";

	// the remaining lines are used to write
	// out the contents of $contents to the 
	// specified file. Hmmm, should we force
	// a file creation if the cache file
	// doesn't exist?

	// Error messages here should be language entries
	if( strlen($contents) )
	{
		if ( !(file_exists($output_file)) )
		{
			$message = sprintf($lang['phpbbdoctor_cache_file_missing'], $output_file);
			message_die(GENERAL_ERROR, $message);
		}
		if (is_writable($output_file))
		{
			if (!$handle = fopen($output_file, 'w'))
			{
				$message = sprintf($lang['phpbbdoctor_cache_cannot_open'], $output_file);
				message_die(GENERAL_ERROR, $message);
			}

			if (fwrite($handle, $contents) === FALSE)
			{
				$message = sprintf($lang['phpbbdoctor_cache_failed_write'], $output_file);
				message_die (GENERAL_ERROR, $message);
			}

			fclose($handle);
		}
		else
		{
			$message = sprintf($lang['phpbbdoctor_cache_not_writable'], $output_file);
			message_die (GENERAL_ERROR, $message);
		}
	}
}

// This function is called when a cache file is missing
// or empty. The arguments are the table to be cached,
// the array to be populated, the row structure, and
// the cache key. See the above notes for details on
// how the cache_key value is used to determine the
// structure of the array. Note that if this function
// is called we do NOT attempt to recreate the cache
// file for the requested table as we assume there's
// something wrong with permissions.
function phpbbdoctor_populate_cache ($cache_table, &$cache_array, $row_structure, $cache_key = '')
{
	global $db;

	$cache_sql = '';
	if ( ($cache_key <> '') && ($cache_key <> '##SEQ##') )
	{
		$cache_sql = ", $cache_key as cache_key ";
	}

	$sql = 'SELECT  * ' . $cache_sql . '
		FROM ' . $cache_table;
	if (! ($result = $db->sql_query($sql)) )
	{
		message_die (GENERAL_ERROR, 'DEBUG: Invalid cursor', '', __LINE__, __FILE__, $sql);
	}

	$data_set = array();
	$data_set = $db->sql_fetchrowset($result);
	$db->sql_freeresult($result);

	$row_count = count($data_set);
	for($i = 0; $i < $row_count; $i++)
	{
		switch($cache_key)
		{
			case '':
				foreach($row_structure as $key => $value)
				{
					$cache_array[$data_set[$i][$key]] = $data_set[$i][$value];
				}
				break;
			case '##SEQ##':
				foreach($row_structure as $key => $value)
				{
					$cache_array[$i][$key] = $data_set[$i][$value];
				}
				break;
			default:
				foreach($row_structure as $key => $value)
				{
					$cache_array[$data_set[$i]['cache_key']][$key] = $data_set[$i][$value];
				}
			break;
		}
	}

	return;
}

?>